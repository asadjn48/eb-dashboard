// import { db } from '../firebase';
// import { 
//   collection, 
//   getDocs, 
//   query, 
//   orderBy 
// } from 'firebase/firestore';
// import type { PayrollRecord } from '../types';

// const COLLECTION_NAME = 'payroll';

// export const payrollAPI = {
//   getAll: async (): Promise<PayrollRecord[]> => {
//     try {
//       const ref = collection(db, COLLECTION_NAME);
//       const q = query(ref, orderBy('month', 'desc')); // Assuming you sort by month
//       const snapshot = await getDocs(q);
      
//       // If no records exist yet, we might want to return empty or mock data
//       // For now, let's return what's in the DB
//       return snapshot.docs.map(doc => ({
//         id: doc.id,
//         ...doc.data()
//       } as PayrollRecord));
//     } catch (error) {
//       console.error("Error fetching payroll:", error);
//       return [];
//     }
//   },

//   getSummary: async () => {
//     // This logic should ideally be backend or calculated from getAll()
//     // For now, we'll return a placeholder structure that the UI expects
//     // The UI actually calculates some of this itself, but let's provide the API structure
//     return {
//       totalPaid: 0,
//       totalUnpaid: 0,
//       totalAmount: 0
//     };
//   }
// };












// import { db } from '@/firebase'; // Ensure this points to your firebase config
// import { 
//   collection, 
//   getDocs, 
//   addDoc, 
//   deleteDoc, 
//   doc, 
//   query, 
//   orderBy 
// } from 'firebase/firestore';
// import type { PayrollRecord } from '@/types';

// const COLLECTION_NAME = 'payroll';

// export const payrollAPI = {
//   // --- READ: Get All Records ---
//   getAll: async (): Promise<PayrollRecord[]> => {
//     try {
//       const payrollRef = collection(db, COLLECTION_NAME);
//       // Sort by paidDate descending (newest first)
//       const q = query(payrollRef, orderBy('paidDate', 'desc')); 
//       const snapshot = await getDocs(q);

//       return snapshot.docs.map((doc) => ({
//         ...doc.data(),
//         id: doc.id, // IMPORTANT: Overwrite frontend ID with Firestore Document ID
//       })) as PayrollRecord[];
//     } catch (error) {
//       console.error("Error fetching payroll:", error);
//       return [];
//     }
//   },

//   // --- CREATE: Add Salary Payment ---
//   add: async (record: PayrollRecord): Promise<PayrollRecord> => {
//     try {
//       // 1. Remove the temporary random ID generated by the frontend
//       // eslint-disable-next-line @typescript-eslint/no-unused-vars
//       const { id, ...dataToSave } = record;

//       // 2. Add to Firestore
//       const docRef = await addDoc(collection(db, COLLECTION_NAME), dataToSave);
      
//       // 3. Return the object with the REAL Firestore ID so the UI updates correctly
//       return {
//         ...record,
//         id: docRef.id 
//       };
//     } catch (error) {
//       console.error("Error adding payroll record:", error);
//       throw error;
//     }
//   },

//   // --- DELETE: Remove Duplicate/Wrong Entry ---
//   delete: async (id: string): Promise<void> => {
//     try {
//       const recordRef = doc(db, COLLECTION_NAME, id);
//       await deleteDoc(recordRef);
//     } catch (error) {
//       console.error("Error deleting payroll record:", error);
//       throw error;
//     }
//   },

//   // --- HELPER: Summary (Calculated on frontend mostly, but kept for compatibility) ---
//   getSummary: async () => {
//     return {
//       totalPaid: 0,
//       totalUnpaid: 0,
//       totalAmount: 0
//     };
//   }
// };















// import { db } from '@/firebase'; 
// import { collection, getDocs, addDoc, deleteDoc, doc, query, orderBy } from 'firebase/firestore';
// import type { PayrollRecord } from '@/types';

// const COLLECTION_NAME = 'payroll';

// export const payrollAPI = {
//   // 1. Get All Records
//   getAll: async (): Promise<PayrollRecord[]> => {
//     try {
//       const q = query(collection(db, COLLECTION_NAME), orderBy('paidDate', 'desc'));
//       const snapshot = await getDocs(q);
//       return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })) as PayrollRecord[];
//     } catch (error) {
//       console.error("Fetch error:", error);
//       return [];
//     }
//   },

//   // 2. Add New Payment (Fixes "Property add does not exist")
//   add: async (record: PayrollRecord) => {
//     // Remove the fake ID before sending to Firebase
//     // eslint-disable-next-line @typescript-eslint/no-unused-vars
//     const { id, ...data } = record; 
//     const docRef = await addDoc(collection(db, COLLECTION_NAME), data);
//     return { ...record, id: docRef.id };
//   },

//   // 3. Delete Payment (Fixes "Duplicate entries")
//   delete: async (id: string) => {
//     await deleteDoc(doc(db, COLLECTION_NAME, id));
//   }
// };

















// import { db } from '@/firebase'; 
// import { 
//   collection, getDocs, addDoc, deleteDoc, doc, query, orderBy 
// } from 'firebase/firestore';
// import type { PayrollRecord } from '@/types';

// const COLLECTION_NAME = 'payroll';

// export const payrollAPI = {
//   // 1. Get All Records
//   getAll: async (): Promise<PayrollRecord[]> => {
//     try {
//       const q = query(collection(db, COLLECTION_NAME), orderBy('paidDate', 'desc'));
//       const snapshot = await getDocs(q);
//       return snapshot.docs.map(doc => ({ 
//         id: doc.id, 
//         ...doc.data() 
//       })) as PayrollRecord[];
//     } catch (error) {
//       console.error("Fetch error:", error);
//       return [];
//     }
//   },

//   // 2. Add New Payment (FIXED: Clean data before saving)
//   add: async (record: PayrollRecord) => {
//     try {
//       // Remove 'id' (let Firebase generate it) and any undefined fields
//       // eslint-disable-next-line @typescript-eslint/no-unused-vars
//       const { id, ...rest } = record;
      
//       // Sanitization: Ensure no undefined values are passed to Firestore
//       const cleanData = JSON.parse(JSON.stringify(rest)); 

//       const docRef = await addDoc(collection(db, COLLECTION_NAME), cleanData);
//       return { ...record, id: docRef.id };
//     } catch (error) {
//       console.error("Add Error:", error);
//       throw error; // Re-throw so the UI knows it failed
//     }
//   },

//   // 3. Delete Payment
//   delete: async (id: string) => {
//     try {
//       await deleteDoc(doc(db, COLLECTION_NAME, id));
//     } catch (error) {
//       console.error("Delete Error:", error);
//       throw error;
//     }
//   }
// };





















import { db } from '@/firebase'; 
import { 
  collection, getDocs, addDoc, deleteDoc, updateDoc, doc, query, orderBy 
} from 'firebase/firestore';
import type { PayrollRecord } from '@/types';

const COLLECTION_NAME = 'payroll';

export const payrollAPI = {
  // ... (Keep getAll, add, delete as they were) ...

  getAll: async (): Promise<PayrollRecord[]> => {
    try {
      const q = query(collection(db, COLLECTION_NAME), orderBy('paidDate', 'desc'));
      const snapshot = await getDocs(q);
      return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })) as PayrollRecord[];
    } catch (error) { console.error("Fetch error:", error); return []; }
  },

  add: async (record: PayrollRecord) => {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const { id, ...data } = record;
    const docRef = await addDoc(collection(db, COLLECTION_NAME), data);
    return { ...record, id: docRef.id };
  },

  delete: async (id: string) => {
    await deleteDoc(doc(db, COLLECTION_NAME, id));
  },

  // NEW: Update transaction (Edit capability)
  update: async (id: string, updates: Partial<PayrollRecord>) => {
    const docRef = doc(db, COLLECTION_NAME, id);
    await updateDoc(docRef, updates);
  }
};